Actor Cashier {
	UC::processSale() 
} 

Service ProcessSale {
	
	[Operation]
	makeNewSale()
	
	enterItem(barcode, quantity)
	endSale()

	makeCashPayment(amount)
	makeCardPayment(cardAccountNumber, expiryDate) 
	
	
	[TempProperty]
	CurrentSale : Sale
	CurrentCashDesk : CashDesk 
	CurrentStore : Store
	CurrentPaymentMethod : PaymentMethod[CASH|CARD]
	
 
	[WorkFlow]
	ProcessSale
}

Service ThridPartServices {
	
	[Operation]
	thirdPartyCardPaymentService(cdp, expiryDate, currentSale)
}

/* System Work Flow, Not for runing, protocol for Actor inter-active with System */
Workflow ProcessSale {
	
	makeNewSale()
	
	Loop -> hasMoreItems { 
		enterItem(barcode, quantity)
	}
	
	endSale()
	
	Switch -> PaymentMethod {
		case: PaymentMethod::CASH -> makeCashPayment(amount) 
		case: PaymentMethod::CARD -> makeCardPayment(cardAccountNumber, expiryDate) 
	}
	
}

Entity Store {
	Id : Integer
	Name : String
	Address : String
	
	[Refer]
	Cashdeskes : CashDesk*
	Productcatalogs : ProductCatalog*
	Items : Item*
	Cashiers : Cashier*
	Sales : Sale*
	
}

Entity ProductCatalog {
	Name : String
}

Entity CashDesk {
	
	Id : Integer
	
	[Refer]
	ContainedSales : Sale*
	BelongedStore : Store
}

Entity Sale {
	
	Time : Date
	IsComplete: Boolean
	Amount : Real
	IsReadytoPay : Boolean
	
    [Refer] 
    Belongedstore : Store
    BelongedCashDesk : CashDesk 
    ContainedSalesLine : SalesLineItem*
    AssoicatedPayment : Payment
}

Entity Cashier {
	Id : Integer
	Name : String
	
	[Refer]
	WorkedStore : Store
}


Entity SalesLineItem {
	
	Quantity : Integer
	Subamount : Real
	
	[Refer]
	BelongedSale : Sale
	BelongedItem : Item
}

Entity Item {
	Barcode : Integer
	Description : String
	Price : Real
	
	[Refer]
	BelongedCatalog : ProductCatalog
}

Entity Payment {
	
	AmountTendered : Real
	
	[Refer]
	BelongedSale : Sale
}

Entity CashPayment extends Payment {
	Balance : Real
}

Entity CardPayment extends Payment {
	CardAccountNumber : Integer
	ExpiryDate : Date
}


Contract makeNewSale()  {
				
	/* preconditions:  none */
	precondition: true
	
	/* postconditions: 
	 * A sale instance s was created (instance creation).
	 * s was associated with the current CashDesk (association formed)
	 * Attribute of s were initialized. (object initialization)
	 */
	postcondition:  let s:Sale in s.oclIsNew() and s.BelongedCashDesk = CurrentCashDesk and CurrentCashDesk.ContainedSales->includes(s) and s.IsComplete = false and self.CurrentSale = s
}

Contract enterItem(barcode : Item, quantity : Integer) {
	
	/* Definition: find item instance, based on barcode */
	definition: item:Item = Item.allInstance()->any(i:Item | i.Barcode = barcode)
	
	/* Precondition: there is a sale underway */
	precondition: CurrentSale.IsComplete = false
	
	/**
	 * A salesLineItem instance sli was created (instance creation).
	 * sli was associated with the current Sale (association formed).
	 * sli.quantity became quantity (attribute modification).
	 * sli was associated with a Item (association formed). 
	 * subamount became item.price * quantity ?
	 */
	 postcondition : let sli:SalesLineItem in sli.oclIsNew() and sli.BelongedSale = CurrentSale and CurrentSale.ContainedSalesLine->includes(sli) and
	 				 sli.Quantity = quantity and sli.BelongedItem = item and sli.Subamount = item.Price * quantity
}


Contract endSale() {
	
	/* Precondition: there is a sale underway and all items have been entered. */
	precondition: CurrentSale.IsComplete = false and IsReadytoPay = false
	
	/**
	 * Postcondition: 
	 */
	postcondition: CurrentSale.containedSalesLine->forAll(sl : SalesLineItem | CurrentSale.Amount = CurrentSale.Amount@pre + sl.Subamount) and IsReadytoPay = true
}

Contract makeCashPayment(amount : Real) {
	
	/* Precondition: There is a sale underway, all items have been entered, and tendered amount is greater than or equal to the amount of current Sale*/
	precondition: CurrentSale.IsComplete = false and  IsReadytoPay = true and amount >= CurrentSale.Amount 
	
	/**
	 * A CashPayment instance cp was created (instance creation).
	 * cp.amountTendered became amount (attribute modification).
	 * cp was associated with the current Sale (association formed).
	 * The current Sale was associated with the Store (association formed).
	 * Sale.isComplete became true (attribute modification)
	 * Sale.time became now 
	 */
	 postcondition: let cp:CashPayment in cp.oclIsNew() and cp.AmountTendered = amount and cp.Balance = amout - CurrentSale.Amount 
	 				and cp.sale = CurrentSale and CurrentSale.assoicatedPayment = cp and CurrentSale.store = CurrentStore and CurrentStore.Sales->includes(currentSale) and CurrentSale.IsComplete = true and CurrentSale.Time = Now
	  
}

Contract makeCardPayment(cardAccountNumber : Integer, expiryDate : Date) {
	
	/* Precondition: An underway sale exists and all items have been entered. */
	precondition:  CurrentSale.IsComplete = false and IsReadytoPay = true 
	
	/**
	 * a CardPayment pmt was created
	 * cdp was associated with the current Sale
	 * cdp.number = cardAccountNumber, cdp.expiryDate = expiryDate
	 * invoke third party card payment service 
	 * sale was associated with the Store as a completed sale
	 * Sale.time became now 
	 */
	 postcondition: let cdp:CardPayment in cp.oclIsNew() and cdp.Number = cardAccountNumber and cdp.ExpiryDate = expiryDate and thirdPartyCardPaymentService(cdp, expiryDate, currentSale) = true 
	 				and cdp.Sale = currentSale and currentSale.assoicatedPayment = cdp and currentSale.belongedStore = currentStore and currentStore.sales->includes(currentSale) and currentSale.IsComplete = true and currentSale.Time = Now
	 
}

Contract  thirdPartyCardPaymentService(cdp : CardPayment, expiryDate : Date, currentSale : Sale)  {
	precondition: true
	postcondition: true
}