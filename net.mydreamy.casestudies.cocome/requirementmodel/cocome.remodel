Actor Cashier {
	UC::processSale() 
} 

Service ProcessSale {
	
	[Operation]
	makeNewSale()
	
	enterItem(barcode, quantity)
	endSale()

	makeCashPayment(amount)
	makeCardPayment(cardAccountNumber, expiryDate) 
	
	
	[TempProperty]
	currentSale : Sale
	currentCashDesk : CashDesk 
	currentStore : Store
	currentPaymentMethod : PaymentMethod[CASH|CARD]
	 
	[WorkFlow]
	ProcessSaleWF
}

Service ThridPartServices {
	
	[Operation]
	thirdPartyCardPaymentService(cdp, expiryDate, currentSale)
}

/* System Work Flow, Not for runing, protocol for Actor inter-active with System */
Workflow ProcessSaleWF {
	
	[Cashier ProcessSale]
	
	makeNewSale()
	
	Loop -> hasMoreItems { 
		enterItem(barcode, quantity)
	}
	
	endSale()
	
	Switch -> PaymentMethod {
		case: PaymentMethod::CASH -> makeCashPayment(amount) 
		case: PaymentMethod::CARD -> makeCardPayment(cardAccountNumber, expiryDate) 
	}
	 
}

Interaction ProcessSaleInteraction {
	
	[Participants: Cashier ProcessSale]
	
	Message:makeNewSale(makeNewSaleSender->makeNewSaleReceiver)
	Message:endSale(endSaleSender->endSaleReceiver)
	
	Execution:makeNewSale(ProcessSale makeNewSaleStart makeNewSaleFinish)
	Execution:endSale(ProcessSale endSaleStart endSaleFinish)
	 
	CombinedFragment:enterItemLoop->loop {
		
		[Participants: Cashier ProcessSale]
		
		enterItemLoopStart->enterItemLoopFinish
		
		Operand::hasMoreItems(hasMoreItemsEnd)
		
	} 
	
	CombinedFragment:PaymentMethodAlt->alt {
		
		[Participants: Cashier ProcessSale]
		
		PaymentMethodAltStart->PaymentMethodAltFinish
		
		Operand::Cash(CashEnd)
		Operand::Card(CardEnd)
		
	} 
	 
	MessageEnd::makeNewSaleSender(Cashier makeNewSale)
	MessageEnd::makeNewSaleReceiver(ProcessSale makeNewSale)
	
	ExecutionEnd::makeNewSaleStart(ProcessSale makeNewSale)
	ExecutionEnd::makeNewSaleFinish(ProcessSale makeNewSale)
	
	CombinedFragmentEnd::enterItemLoopStart(ProcessSale enterItemLoop)
	CombinedFragmentEnd::enterItemLoopFinish(ProcessSale enterItemLoop)
	
	OperandEnd::hasMoreItemsEnd(ProcessSale hasMoreItems)
	
	CombinedFragmentEnd::PaymentMethodAltStart(ProcessSale PaymentMethodAlt)
	CombinedFragmentEnd::PaymentMethodAltFinish(ProcessSale PaymentMethodAlt)	

	OperandEnd::CashEnd(ProcessSale Cash)
	OperandEnd::CardEnd(ProcessSale Card)
		
	MessageEnd::endSaleSender(Cashier endSale)
	MessageEnd::endSaleReceiver(ProcessSale endSale)
	
	ExecutionEnd::endSaleStart(ProcessSale endSale)
	ExecutionEnd::endSaleFinish(ProcessSale endSale)
	
}



Entity Store {
	Id : Integer
	Name : String
	Address : String
	
	[Refer]
	Cashdeskes : CashDesk*
	Productcatalogs : ProductCatalog*
	Items : Item*
	Cashiers : Cashier*
	Sales : Sale*
	
}

Entity ProductCatalog {
	Name : String
}

Entity CashDesk {
	
	Id : Integer
	
	[Refer]
	ContainedSales : Sale*
	BelongedStore : Store
}

Entity Sale {
	
	Time : Date
	IsComplete: Boolean
	Amount : Real
	IsReadytoPay : Boolean
	
    [Refer] 
    Belongedstore : Store
    BelongedCashDesk : CashDesk 
    ContainedSalesLine : SalesLineItem*
    AssoicatedPayment : Payment
}

Entity Cashier {
	Id : Integer
	Name : String
	
	[Refer]
	WorkedStore : Store
}


Entity SalesLineItem {
	
	Quantity : Integer
	Subamount : Real
	
	[Refer]
	BelongedSale : Sale
	BelongedItem : Item
}

Entity Item {
	Barcode : Integer
	Description : String
	Price : Real
	
	[Refer]
	BelongedCatalog : ProductCatalog
}

Entity Payment {
	
	AmountTendered : Real
	
	[Refer]
	BelongedSale : Sale
}

Entity CashPayment extends Payment {
	Balance : Real
}

Entity CardPayment extends Payment {
	CardAccountNumber : Integer
	ExpiryDate : Date
}

 
Contract ProcessSale::makeNewSale()  {
				 
	/* preconditions:  none */
	precondition: true
	
	/* postconditions: 
	 * A sale instance s was created (instance creation).
	 * s was associated with the current CashDesk (association formed)
	 * Attribute IsComplete of s was initialized as false. (object initialization)
	 * currentSale became s
	 */ 
	postcondition:  let s:Sale in s.oclIsNew() and 
					s.BelongedCashDesk = currentCashDesk and currentCashDesk.ContainedSales->includes(s) and 
					s.IsComplete = false and 
					self.currentSale = s
}

Contract ProcessSale::enterItem(barcode : Integer, quantity : Integer) {
	
	/* Definition: find specific Item instance by barcode */
	definition: item:Item = Item.allInstance()->any(i:Item | i.Barcode = barcode)
	
	/* Precondition: there is a sale underway */
	precondition: currentSale.IsComplete = false 
	
	/**
	 * A salesLineItem instance sli was created (instance creation).
	 * sli was associated with the current Sale (association formed).
	 * sli.quantity became quantity (attribute modification).
	 * sli was associated with a Item (association formed). 
	 * subamount became item.price * quantity 
	 */
	 postcondition : let sli:SalesLineItem in sli.oclIsNew() and 
	 				 sli.BelongedSale = currentSale and currentSale.ContainedSalesLine->includes(sli) and
	 				 sli.Quantity = quantity and 
	 				 sli.BelongedItem = item and 
	 				 sli.Subamount = item.Price * quantity
}


Contract ProcessSale::endSale() {
	
	/* Precondition: there is a sale underway and no more items. */
	precondition: currentSale.IsComplete = false and currentSale.IsReadytoPay = false
	
	/**
	 * Postcondition: 
	 * add all sub amount of SalesLineItem up to the Amount of currentSale (compute amount).
	 * currentSale.IsReadytoPay became true
	 */
	postcondition: currentSale.ContainedSalesLine->forAll(sl : SalesLineItem | currentSale.Amount = currentSale.Amount@pre + sl.Subamount) and currentSale.IsReadytoPay = true
}

Contract ProcessSale::makeCashPayment(amount : Real) {
	
	/* Precondition: There is a sale underway, the sale is ready to pay, and tendered amount is greater than or equal to the amount of current Sale*/
	precondition: currentSale.IsComplete = false and  currentSale.IsReadytoPay = true and amount >= currentSale.Amount 
	 
	/**
	 * A CashPayment instance cp was created (instance creation).
	 * cp.amountTendered became amount (attribute modification).
	 * cp was associated with the current Sale (association formed).
	 * The current Sale was associated with the Store (association formed).
	 * Sale.isComplete became true (attribute modification).
	 * Sale.time became now  (attribute modification).
	 * cp.Balance became the value of tendered amount minus current Sale amount
	 */
	 postcondition: let cp:CashPayment in cp.oclIsNew() and 
	 				cp.AmountTendered = amount and 
	 				cp.BelongedSale = currentSale and currentSale.AssoicatedPayment = cp  
	 				and currentSale.Belongedstore = currentStore and currentStore.Sales->includes(currentSale) and 
	 				currentSale.IsComplete = true and currentSale.Time = Now and 
	 				cp.Balance = amount - currentSale.Amount 
	  
}

Contract ProcessSale::makeCardPayment(cardAccountNumber : Integer, expiryDate : Date) {
	
	/* Precondition: An underway sale exists and all items have been entered. */
	precondition:  currentSale.IsComplete = false and currentSale.IsReadytoPay = true 
	
	/**
	 * a CardPayment cdp was created
	 * cdp was associated with the current Sale
	 * cdp.CardAccountNumber = cardAccountNumber, cdp.expiryDate = expiryDate
	 * invoke third party card payment service 
	 * sale was associated with the Store as a completed sale
	 * The current sale is complete
	 * Sale.time became now 
	 */
	 postcondition: let cdp:CardPayment in cp.oclIsNew() and 
	 				cdp.BelongedSale = currentSale and currentSale.AssoicatedPayment = cdp and
	 				cdp.CardAccountNumber = cardAccountNumber and cdp.ExpiryDate = expiryDate and 
	 				thirdPartyCardPaymentService(cdp, expiryDate, currentSale) and
	 				currentSale.Belongedstore = currentStore and currentStore.Sales->includes(currentSale) and 
	 				currentSale.IsComplete = true and currentSale.Time = Now
	 
} 

Contract  ThridPartServices::thirdPartyCardPaymentService(cdp : CardPayment, expiryDate : Date, currentSale : Sale)  {
	precondition: true
	postcondition: true
}